<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>FIDO2 WebAuthn Demo</title>
    <style>
        body {
            font-family: sans-serif;
            max-width: 600px;
            margin: 40px auto;
        }

        h2 {
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }

        input,
        button {
            padding: 10px;
            margin: 5px 0;
            width: 100%;
            box-sizing: border-box;
        }

        .container {
            border: 1px solid #ccc;
            padding: 20px;
            margin-top: 20px;
        }

        #message {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid;
            display: none;
        }
    </style>
</head>

<body>
    <h1>FIDO2/WebAuthn Registration & Auth</h1>

    <div class="container">
        <h2>ðŸ”‘ Registration</h2>
        <input type="text" id="reg-username" placeholder="Enter new username for registration">
        <button onclick="startRegistration()">Register FIDO2 Key</button>
    </div>

    <div class="container">
        <h2>ðŸ”’ Authentication</h2>
        <input type="text" id="auth-username" placeholder="Enter existing username for login">
        <button onclick="startAuthentication()">Authenticate with FIDO2 Key</button>
    </div>

    <div id="message"></div>

    <script>
        const RP_ID = "localhost"; // Must match the backend RP_ID

        // Helper function to convert base64url string to ArrayBuffer
        function base64urlToBuffer(base66url) {
            const padding = '=='.substring(0, (4 - base66url.length % 4) % 4);
            const base64 = (base66url + padding).replace(/-/g, '+').replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray.buffer;
        }

        // Helper function to convert ArrayBuffer to base64url string
        function bufferToBase64url(buffer) {
            const bytes = new Uint8Array(buffer);
            let str = '';
            for (const char of bytes) {
                str += String.fromCharCode(char);
            }
            return window.btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        // Display messages
        function showMessage(text, isError = false) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = text;
            msgEl.style.display = 'block';
            msgEl.style.borderColor = isError ? 'red' : 'green';
            msgEl.style.color = isError ? 'red' : 'green';
        }

        // --- REGISTRATION FLOW ---
        async function startRegistration() {
            const username = document.getElementById('reg-username').value;
            if (!username) {
                showMessage("Please enter a username for registration.", true);
                return;
            }

            showMessage("Starting registration...");

            try {
                // 1. Get challenge/options from backend
                // const response = await fetch('/register/begin', {
                //     method: 'POST',
                //     headers: { 'Content-Type': 'application/json' },
                //     body: JSON.stringify({ username })
                // });

                // if (!response.ok) {
                //     const error = await response.json();
                //     throw new Error(error.error || `HTTP Error: ${response.status}`);
                // }

                // let options = await response.json();
                // console.log("options ", options);

                // // 2. Convert base64url strings in options to ArrayBuffers for the WebAuthn API
                // options.challenge = base64urlToBuffer(options.challenge);
                // options.user.id = base64urlToBuffer(options.user.id);
                // // The pubKeyCredParams is already fine

                // // 3. Call the WebAuthn API to create the credential
                // const credential = await navigator.credentials.create({ publicKey: options });

                // // 4. Convert ArrayBuffers in the response back to base64url for the backend
                // const responseData = {
                //     id: credential.id,
                //     rawId: bufferToBase64url(credential.rawId),
                //     response: {
                //         clientDataJSON: bufferToBase64url(credential.response.clientDataJSON),
                //         attestationObject: bufferToBase64url(credential.response.attestationObject),
                //         // Transports are optional, but good practice to include
                //         transports: credential.response.getTransports ? credential.response.getTransports() : undefined,
                //     },
                //     type: credential.type,
                // };

                // // 5. Send the response back to the backend for verification
                // const verifyResponse = await fetch('/register/complete', {
                //     method: 'POST',
                //     headers: { 'Content-Type': 'application/json' },
                //     body: JSON.stringify(responseData)
                // });

                // if (!verifyResponse.ok) {
                //     const error = await verifyResponse.json();
                //     throw new Error(error.error || `Verification Failed: ${verifyResponse.status}`);
                // }

                // const result = await verifyResponse.json();
                // showMessage(result.message);
                let challenge = base64urlToBuffer("2X9g5iJRVVZHDMMMNJAiYmpk5mckNdUcsdgBWx2Yfnn2FlJKBIGUz5I4KfDFRsPGDMjti1QVRgqCT8V29ijkjQ");
                let user_id = Uint8Array.from(
                    "UZSL85T9AFC", c => c.charCodeAt(0));
                if (!window.PublicKeyCredential) { /* Platform not capable. Handle error. */ }
                console.log("challenge ", challenge);
                const publicKey = {
                    challenge: challenge, // The challenge must be produced by the server

                    // Relying Party:
                    rp: {
                        name: "localhost",
                        id: "localhost"
                    },

                    // User:
                    user: {
                        id: user_id, // id may be generated by the server
                        name: "a.user@example.com",
                        displayName: "A User",
                        icon: "https://example.com/image.png"
                    },

                    // This Relying Party will accept either an ES256 or RS256 credential, but
                    // prefers an ES256 credential.
                    // https://www.iana.org/assignments/cose/cose.xhtml#algorithms
                    pubKeyCredParams: [
                        { type: "public-key", alg: -7 },
                        { type: "public-key", alg: -257 }

                    ],

                    authenticatorSelection: {
                        // 'platform' tells the browser to use the internal authenticator
                        // (TPM, Secure Enclave, etc.) rather than a USB key (YubiKey).
                        authenticatorAttachment: 'cross-platform',

                        userVerification: 'required', // Triggers PIN/Biometrics
                        requireResidentKey: false
                    },

                    attestation: "direct",
                    timeout: 60000,
                    extensions: { "loc": true }  // Include location information in attestation
                };
                console.log("publicKey ", publicKey);

                // Note: The following call will cause the authenticator to display UI.
                navigator.credentials.create({ publicKey: publicKey })
                    .then(function (attestation) {
                        // Send new credential info to server for verification and registration.
                        console.log("attestation : ", JSON.stringify(attestation));
                    }).catch(function (err) {
                        // No acceptable authenticator or user refused consent. Handle appropriately.
                        console.log("err ", err);
                    });


            } catch (error) {
                showMessage(`Registration failed: ${error.message}`, true);
                console.error('Registration Error:', error);
            }
        }


        // --- AUTHENTICATION FLOW ---
        async function startAuthentication() {
            const username = document.getElementById('auth-username').value;
            if (!username) {
                showMessage("Please enter a username for authentication.", true);
                return;
            }

            showMessage("Starting authentication...");


            try {
                // 1. Get the challenge from the server (required for authentication)
                // The server ensures this challenge is fresh and unique to prevent replay attacks.
                let challenge = base64urlToBuffer("Abc_123_DEF_456_GHI_789_JKL_0000000000000000000");

                // 2. Specify the credential IDs the authenticator should look for
                // In a real app, this list comes from the server and contains the credential IDs
                // previously registered by this user.
                let credentialId1 = base64urlToBuffer("QJncNVNxqteWHTx3mmh_iXHDAv1Sx6tYBOOiGh2pSI0");
                let credentialId2 = base64urlToBuffer("Zmpk5mckNdUcsdgBWx2Yfnn2FlJKBIGUz5I4KfD");


                if (!window.PublicKeyCredential) { /* Platform not capable. Handle error. */ }
                console.log("challenge ", challenge);

                var publicKey = {
                    // The challenge must be produced by the server
                    challenge: challenge,

                    // The list of public key credentials the client should attempt to use for authentication
                    allowCredentials: [
                        {
                            // The credential ID from the server
                            id: credentialId1,
                            // Must be 'public-key'
                            type: 'public-key',
                            // Transports can hint to the browser where to look (e.g., USB, NFC, internal)
                            transports: ['usb', 'nfc', 'internal']
                        },
                        {
                            id: credentialId2,
                            type: 'public-key'
                        }
                    ],

                    // The Relying Party ID is derived from the current site's origin (e.g., 'example.com')
                    // It's usually safe to omit this and let the browser infer it, but it can be specified.
                    // rpId: "demo.server.com",

                    timeout: 60000,
                    userVerification: 'preferred', // User consent (PIN/biometrics) is preferred, not strictly required
                    extensions: { "loc": true } // Optional: Request location info if supported
                };
                console.log("publicKey for get ", publicKey);

                const publicKeyCredentialRequestOptions = {
                    challenge: Uint8Array.from(/* server challenge */),
                    allowCredentials: [{
                        id: Uint8Array.from(/* stored credential ID */),
                        type: 'public-key',
                        transports: ['internal'] // 'internal' hints at platform authenticators
                    }],
                    userVerification: 'required'
                };


                // Note: The following call will cause the authenticator to display UI for authentication.
                navigator.credentials.get({ publicKey })
                    .then(function (assertion) {
                        // Send the resulting assertion to the server for verification.
                        console.log("assertion : ", JSON.stringify(assertion));
                    }).catch(function (err) {
                        // User refused consent or no acceptable authenticator/credential found. Handle appropriately.
                        console.log("err ", err);
                    });

            } catch (error) {
                console.error('Authentication Error:', error);
            }

            // try {
            // 1. Get challenge/options from backend
            // const response = await fetch('/auth/begin', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify({ username })
            // });

            // if (!response.ok) {
            //     const error = await response.json();
            //     throw new Error(error.error || `HTTP Error: ${response.status}`);
            // }

            //     let options = await response.json();

            //     // 2. Convert base64url strings in options to ArrayBuffers
            //     options.challenge = base64urlToBuffer(options.challenge);
            //     // Credential IDs must also be converted to ArrayBuffer
            //     options.allowCredentials = options.allowCredentials.map(cred => ({
            //         ...cred,
            //         id: base64urlToBuffer(cred.id)
            //     }));

            //     // 3. Call the WebAuthn API to get the assertion
            //     const assertion = await navigator.credentials.get({ publicKey: options });

            //     // 4. Convert ArrayBuffers in the response back to base64url for the backend
            //     const responseData = {
            //         id: assertion.id,
            //         rawId: bufferToBase64url(assertion.rawId),
            //         response: {
            //             clientDataJSON: bufferToBase64url(assertion.response.clientDataJSON),
            //             authenticatorData: bufferToBase64url(assertion.response.authenticatorData),
            //             signature: bufferToBase64url(assertion.response.signature),
            //             userHandle: assertion.response.userHandle ? bufferToBase64url(assertion.response.userHandle) : null,
            //         },
            //         type: assertion.type,
            //     };

            //     // 5. Send the response back to the backend for verification
            //     const verifyResponse = await fetch('/auth/complete', {
            //         method: 'POST',
            //         headers: { 'Content-Type': 'application/json' },
            //         body: JSON.stringify(responseData)
            //     });

            //     if (!verifyResponse.ok) {
            //         const error = await verifyResponse.json();
            //         throw new Error(error.error || `Verification Failed: ${verifyResponse.status}`);
            //     }

            //     const result = await verifyResponse.json();
            //     showMessage(result.message);

            // } catch (error) {
            //     showMessage(`Authentication failed: ${error.message}`, true);
            //     console.error('Authentication Error:', error);
            // }
        }
    </script>
</body>

</html>