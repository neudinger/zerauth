// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROVINGPHASE_ZERAUTH_H_
#define FLATBUFFERS_GENERATED_PROVINGPHASE_ZERAUTH_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace zerauth {

struct Proving;
struct ProvingBuilder;
struct ProvingT;

inline const ::flatbuffers::TypeTable *ProvingTypeTable();

struct ProvingT : public ::flatbuffers::NativeTable {
  typedef Proving TableType;
  std::string nonce{};
  std::string challenge{};
  std::string salt{};
};

struct Proving FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProvingT NativeTableType;
  typedef ProvingBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProvingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NONCE = 4,
    VT_CHALLENGE = 6,
    VT_SALT = 8
  };
  const ::flatbuffers::String *nonce() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NONCE);
  }
  ::flatbuffers::String *mutable_nonce() {
    return GetPointer<::flatbuffers::String *>(VT_NONCE);
  }
  const ::flatbuffers::String *challenge() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHALLENGE);
  }
  ::flatbuffers::String *mutable_challenge() {
    return GetPointer<::flatbuffers::String *>(VT_CHALLENGE);
  }
  const ::flatbuffers::String *salt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SALT);
  }
  ::flatbuffers::String *mutable_salt() {
    return GetPointer<::flatbuffers::String *>(VT_SALT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NONCE) &&
           verifier.VerifyString(nonce()) &&
           VerifyOffset(verifier, VT_CHALLENGE) &&
           verifier.VerifyString(challenge()) &&
           VerifyOffset(verifier, VT_SALT) &&
           verifier.VerifyString(salt()) &&
           verifier.EndTable();
  }
  ProvingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProvingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Proving> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProvingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProvingBuilder {
  typedef Proving Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nonce(::flatbuffers::Offset<::flatbuffers::String> nonce) {
    fbb_.AddOffset(Proving::VT_NONCE, nonce);
  }
  void add_challenge(::flatbuffers::Offset<::flatbuffers::String> challenge) {
    fbb_.AddOffset(Proving::VT_CHALLENGE, challenge);
  }
  void add_salt(::flatbuffers::Offset<::flatbuffers::String> salt) {
    fbb_.AddOffset(Proving::VT_SALT, salt);
  }
  explicit ProvingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Proving> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Proving>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Proving> CreateProving(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nonce = 0,
    ::flatbuffers::Offset<::flatbuffers::String> challenge = 0,
    ::flatbuffers::Offset<::flatbuffers::String> salt = 0) {
  ProvingBuilder builder_(_fbb);
  builder_.add_salt(salt);
  builder_.add_challenge(challenge);
  builder_.add_nonce(nonce);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Proving> CreateProvingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nonce = nullptr,
    const char *challenge = nullptr,
    const char *salt = nullptr) {
  auto nonce__ = nonce ? _fbb.CreateString(nonce) : 0;
  auto challenge__ = challenge ? _fbb.CreateString(challenge) : 0;
  auto salt__ = salt ? _fbb.CreateString(salt) : 0;
  return zerauth::CreateProving(
      _fbb,
      nonce__,
      challenge__,
      salt__);
}

::flatbuffers::Offset<Proving> CreateProving(::flatbuffers::FlatBufferBuilder &_fbb, const ProvingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ProvingT *Proving::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProvingT>(new ProvingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Proving::UnPackTo(ProvingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nonce(); if (_e) _o->nonce = _e->str(); }
  { auto _e = challenge(); if (_e) _o->challenge = _e->str(); }
  { auto _e = salt(); if (_e) _o->salt = _e->str(); }
}

inline ::flatbuffers::Offset<Proving> Proving::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ProvingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProving(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Proving> CreateProving(::flatbuffers::FlatBufferBuilder &_fbb, const ProvingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ProvingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nonce = _o->nonce.empty() ? 0 : _fbb.CreateString(_o->nonce);
  auto _challenge = _o->challenge.empty() ? 0 : _fbb.CreateString(_o->challenge);
  auto _salt = _o->salt.empty() ? 0 : _fbb.CreateString(_o->salt);
  return zerauth::CreateProving(
      _fbb,
      _nonce,
      _challenge,
      _salt);
}

inline const ::flatbuffers::TypeTable *ProvingTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "nonce",
    "challenge",
    "salt"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const zerauth::Proving *GetProving(const void *buf) {
  return ::flatbuffers::GetRoot<zerauth::Proving>(buf);
}

inline const zerauth::Proving *GetSizePrefixedProving(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<zerauth::Proving>(buf);
}

inline Proving *GetMutableProving(void *buf) {
  return ::flatbuffers::GetMutableRoot<Proving>(buf);
}

inline zerauth::Proving *GetMutableSizePrefixedProving(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<zerauth::Proving>(buf);
}

inline bool VerifyProvingBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<zerauth::Proving>(nullptr);
}

inline bool VerifySizePrefixedProvingBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<zerauth::Proving>(nullptr);
}

inline void FinishProvingBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zerauth::Proving> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProvingBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zerauth::Proving> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<zerauth::ProvingT> UnPackProving(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<zerauth::ProvingT>(GetProving(buf)->UnPack(res));
}

inline std::unique_ptr<zerauth::ProvingT> UnPackSizePrefixedProving(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<zerauth::ProvingT>(GetSizePrefixedProving(buf)->UnPack(res));
}

}  // namespace zerauth

#endif  // FLATBUFFERS_GENERATED_PROVINGPHASE_ZERAUTH_H_
