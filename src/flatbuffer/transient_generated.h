// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSIENT_ZERAUTH_H_
#define FLATBUFFERS_GENERATED_TRANSIENT_ZERAUTH_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "proving_phase_generated.h"
#include "setup_phase_generated.h"

namespace zerauth {

struct Transient;
struct TransientBuilder;
struct TransientT;

inline const ::flatbuffers::TypeTable *TransientTypeTable();

struct TransientT : public ::flatbuffers::NativeTable {
  typedef Transient TableType;
  std::unique_ptr<zerauth::SetupT> setup{};
  std::unique_ptr<zerauth::ProvingT> proving{};
  std::vector<std::string> challenge_coordinates{};
  TransientT() = default;
  TransientT(const TransientT &o);
  TransientT(TransientT&&) FLATBUFFERS_NOEXCEPT = default;
  TransientT &operator=(TransientT o) FLATBUFFERS_NOEXCEPT;
};

struct Transient FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransientT NativeTableType;
  typedef TransientBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransientTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETUP = 4,
    VT_PROVING = 6,
    VT_CHALLENGE_COORDINATES = 8
  };
  const zerauth::Setup *setup() const {
    return GetPointer<const zerauth::Setup *>(VT_SETUP);
  }
  zerauth::Setup *mutable_setup() {
    return GetPointer<zerauth::Setup *>(VT_SETUP);
  }
  const zerauth::Proving *proving() const {
    return GetPointer<const zerauth::Proving *>(VT_PROVING);
  }
  zerauth::Proving *mutable_proving() {
    return GetPointer<zerauth::Proving *>(VT_PROVING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *challenge_coordinates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CHALLENGE_COORDINATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_challenge_coordinates() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CHALLENGE_COORDINATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SETUP) &&
           verifier.VerifyTable(setup()) &&
           VerifyOffset(verifier, VT_PROVING) &&
           verifier.VerifyTable(proving()) &&
           VerifyOffset(verifier, VT_CHALLENGE_COORDINATES) &&
           verifier.VerifyVector(challenge_coordinates()) &&
           verifier.VerifyVectorOfStrings(challenge_coordinates()) &&
           verifier.EndTable();
  }
  TransientT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransientT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Transient> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransientT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransientBuilder {
  typedef Transient Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_setup(::flatbuffers::Offset<zerauth::Setup> setup) {
    fbb_.AddOffset(Transient::VT_SETUP, setup);
  }
  void add_proving(::flatbuffers::Offset<zerauth::Proving> proving) {
    fbb_.AddOffset(Transient::VT_PROVING, proving);
  }
  void add_challenge_coordinates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> challenge_coordinates) {
    fbb_.AddOffset(Transient::VT_CHALLENGE_COORDINATES, challenge_coordinates);
  }
  explicit TransientBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Transient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Transient>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Transient> CreateTransient(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<zerauth::Setup> setup = 0,
    ::flatbuffers::Offset<zerauth::Proving> proving = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> challenge_coordinates = 0) {
  TransientBuilder builder_(_fbb);
  builder_.add_challenge_coordinates(challenge_coordinates);
  builder_.add_proving(proving);
  builder_.add_setup(setup);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Transient> CreateTransientDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<zerauth::Setup> setup = 0,
    ::flatbuffers::Offset<zerauth::Proving> proving = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *challenge_coordinates = nullptr) {
  auto challenge_coordinates__ = challenge_coordinates ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*challenge_coordinates) : 0;
  return zerauth::CreateTransient(
      _fbb,
      setup,
      proving,
      challenge_coordinates__);
}

::flatbuffers::Offset<Transient> CreateTransient(::flatbuffers::FlatBufferBuilder &_fbb, const TransientT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TransientT::TransientT(const TransientT &o)
      : setup((o.setup) ? new zerauth::SetupT(*o.setup) : nullptr),
        proving((o.proving) ? new zerauth::ProvingT(*o.proving) : nullptr),
        challenge_coordinates(o.challenge_coordinates) {
}

inline TransientT &TransientT::operator=(TransientT o) FLATBUFFERS_NOEXCEPT {
  std::swap(setup, o.setup);
  std::swap(proving, o.proving);
  std::swap(challenge_coordinates, o.challenge_coordinates);
  return *this;
}

inline TransientT *Transient::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransientT>(new TransientT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Transient::UnPackTo(TransientT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = setup(); if (_e) { if(_o->setup) { _e->UnPackTo(_o->setup.get(), _resolver); } else { _o->setup = std::unique_ptr<zerauth::SetupT>(_e->UnPack(_resolver)); } } else if (_o->setup) { _o->setup.reset(); } }
  { auto _e = proving(); if (_e) { if(_o->proving) { _e->UnPackTo(_o->proving.get(), _resolver); } else { _o->proving = std::unique_ptr<zerauth::ProvingT>(_e->UnPack(_resolver)); } } else if (_o->proving) { _o->proving.reset(); } }
  { auto _e = challenge_coordinates(); if (_e) { _o->challenge_coordinates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->challenge_coordinates[_i] = _e->Get(_i)->str(); } } else { _o->challenge_coordinates.resize(0); } }
}

inline ::flatbuffers::Offset<Transient> Transient::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransientT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransient(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Transient> CreateTransient(::flatbuffers::FlatBufferBuilder &_fbb, const TransientT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransientT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _setup = _o->setup ? CreateSetup(_fbb, _o->setup.get(), _rehasher) : 0;
  auto _proving = _o->proving ? CreateProving(_fbb, _o->proving.get(), _rehasher) : 0;
  auto _challenge_coordinates = _o->challenge_coordinates.size() ? _fbb.CreateVectorOfStrings(_o->challenge_coordinates) : 0;
  return zerauth::CreateTransient(
      _fbb,
      _setup,
      _proving,
      _challenge_coordinates);
}

inline const ::flatbuffers::TypeTable *TransientTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    zerauth::SetupTypeTable,
    zerauth::ProvingTypeTable
  };
  static const char * const names[] = {
    "setup",
    "proving",
    "challenge_coordinates"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const zerauth::Transient *GetTransient(const void *buf) {
  return ::flatbuffers::GetRoot<zerauth::Transient>(buf);
}

inline const zerauth::Transient *GetSizePrefixedTransient(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<zerauth::Transient>(buf);
}

inline Transient *GetMutableTransient(void *buf) {
  return ::flatbuffers::GetMutableRoot<Transient>(buf);
}

inline zerauth::Transient *GetMutableSizePrefixedTransient(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<zerauth::Transient>(buf);
}

inline bool VerifyTransientBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<zerauth::Transient>(nullptr);
}

inline bool VerifySizePrefixedTransientBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<zerauth::Transient>(nullptr);
}

inline void FinishTransientBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zerauth::Transient> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTransientBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zerauth::Transient> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<zerauth::TransientT> UnPackTransient(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<zerauth::TransientT>(GetTransient(buf)->UnPack(res));
}

inline std::unique_ptr<zerauth::TransientT> UnPackSizePrefixedTransient(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<zerauth::TransientT>(GetSizePrefixedTransient(buf)->UnPack(res));
}

}  // namespace zerauth

#endif  // FLATBUFFERS_GENERATED_TRANSIENT_ZERAUTH_H_
