// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SETUPPHASE_ZERAUTH_H_
#define FLATBUFFERS_GENERATED_SETUPPHASE_ZERAUTH_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace zerauth {

struct Setup;
struct SetupBuilder;
struct SetupT;

inline const ::flatbuffers::TypeTable *SetupTypeTable();

struct SetupT : public ::flatbuffers::NativeTable {
  typedef Setup TableType;
  std::vector<std::string> curve_names{};
  std::vector<std::string> postulate_coordinates{};
  std::vector<std::string> commitment_coordinates{};
};

struct Setup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetupT NativeTableType;
  typedef SetupBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetupTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVE_NAMES = 4,
    VT_POSTULATE_COORDINATES = 6,
    VT_COMMITMENT_COORDINATES = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *curve_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CURVE_NAMES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_curve_names() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CURVE_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *postulate_coordinates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_POSTULATE_COORDINATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_postulate_coordinates() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_POSTULATE_COORDINATES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *commitment_coordinates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMITMENT_COORDINATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_commitment_coordinates() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMITMENT_COORDINATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURVE_NAMES) &&
           verifier.VerifyVector(curve_names()) &&
           verifier.VerifyVectorOfStrings(curve_names()) &&
           VerifyOffset(verifier, VT_POSTULATE_COORDINATES) &&
           verifier.VerifyVector(postulate_coordinates()) &&
           verifier.VerifyVectorOfStrings(postulate_coordinates()) &&
           VerifyOffset(verifier, VT_COMMITMENT_COORDINATES) &&
           verifier.VerifyVector(commitment_coordinates()) &&
           verifier.VerifyVectorOfStrings(commitment_coordinates()) &&
           verifier.EndTable();
  }
  SetupT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetupT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Setup> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetupT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetupBuilder {
  typedef Setup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_curve_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> curve_names) {
    fbb_.AddOffset(Setup::VT_CURVE_NAMES, curve_names);
  }
  void add_postulate_coordinates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> postulate_coordinates) {
    fbb_.AddOffset(Setup::VT_POSTULATE_COORDINATES, postulate_coordinates);
  }
  void add_commitment_coordinates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> commitment_coordinates) {
    fbb_.AddOffset(Setup::VT_COMMITMENT_COORDINATES, commitment_coordinates);
  }
  explicit SetupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Setup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Setup>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Setup> CreateSetup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> curve_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> postulate_coordinates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> commitment_coordinates = 0) {
  SetupBuilder builder_(_fbb);
  builder_.add_commitment_coordinates(commitment_coordinates);
  builder_.add_postulate_coordinates(postulate_coordinates);
  builder_.add_curve_names(curve_names);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Setup> CreateSetupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *curve_names = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *postulate_coordinates = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *commitment_coordinates = nullptr) {
  auto curve_names__ = curve_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*curve_names) : 0;
  auto postulate_coordinates__ = postulate_coordinates ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*postulate_coordinates) : 0;
  auto commitment_coordinates__ = commitment_coordinates ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*commitment_coordinates) : 0;
  return zerauth::CreateSetup(
      _fbb,
      curve_names__,
      postulate_coordinates__,
      commitment_coordinates__);
}

::flatbuffers::Offset<Setup> CreateSetup(::flatbuffers::FlatBufferBuilder &_fbb, const SetupT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SetupT *Setup::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetupT>(new SetupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Setup::UnPackTo(SetupT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = curve_names(); if (_e) { _o->curve_names.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->curve_names[_i] = _e->Get(_i)->str(); } } else { _o->curve_names.resize(0); } }
  { auto _e = postulate_coordinates(); if (_e) { _o->postulate_coordinates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->postulate_coordinates[_i] = _e->Get(_i)->str(); } } else { _o->postulate_coordinates.resize(0); } }
  { auto _e = commitment_coordinates(); if (_e) { _o->commitment_coordinates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commitment_coordinates[_i] = _e->Get(_i)->str(); } } else { _o->commitment_coordinates.resize(0); } }
}

inline ::flatbuffers::Offset<Setup> Setup::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetupT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetup(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Setup> CreateSetup(::flatbuffers::FlatBufferBuilder &_fbb, const SetupT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetupT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _curve_names = _o->curve_names.size() ? _fbb.CreateVectorOfStrings(_o->curve_names) : 0;
  auto _postulate_coordinates = _o->postulate_coordinates.size() ? _fbb.CreateVectorOfStrings(_o->postulate_coordinates) : 0;
  auto _commitment_coordinates = _o->commitment_coordinates.size() ? _fbb.CreateVectorOfStrings(_o->commitment_coordinates) : 0;
  return zerauth::CreateSetup(
      _fbb,
      _curve_names,
      _postulate_coordinates,
      _commitment_coordinates);
}

inline const ::flatbuffers::TypeTable *SetupTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "curve_names",
    "postulate_coordinates",
    "commitment_coordinates"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const zerauth::Setup *GetSetup(const void *buf) {
  return ::flatbuffers::GetRoot<zerauth::Setup>(buf);
}

inline const zerauth::Setup *GetSizePrefixedSetup(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<zerauth::Setup>(buf);
}

inline Setup *GetMutableSetup(void *buf) {
  return ::flatbuffers::GetMutableRoot<Setup>(buf);
}

inline zerauth::Setup *GetMutableSizePrefixedSetup(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<zerauth::Setup>(buf);
}

inline bool VerifySetupBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<zerauth::Setup>(nullptr);
}

inline bool VerifySizePrefixedSetupBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<zerauth::Setup>(nullptr);
}

inline void FinishSetupBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zerauth::Setup> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSetupBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zerauth::Setup> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<zerauth::SetupT> UnPackSetup(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<zerauth::SetupT>(GetSetup(buf)->UnPack(res));
}

inline std::unique_ptr<zerauth::SetupT> UnPackSizePrefixedSetup(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<zerauth::SetupT>(GetSizePrefixedSetup(buf)->UnPack(res));
}

}  // namespace zerauth

#endif  // FLATBUFFERS_GENERATED_SETUPPHASE_ZERAUTH_H_
